# Changelog v0.5.2

## [0.5.2] - 2026-02-14

### Critical Bug Fix - Content Hash Strategy for Inline-Level SDTs

This release fixes a **High severity regression** introduced in v0.4.2 where inline-level `Text`/`TextRun` elements sharing a content hash with body-level paragraphs cause an unrecoverable `RuntimeException` during `save()`.

---

### Root Cause

In v0.4.2, the lookup strategy order in `ElementLocator::findElementInDOM()` was changed to prioritize content hash over type+order:

**Before v0.4.2 (working):**
```
Strategy 1: findByTypeAndOrder()  →  includes findTextInCell() for Text/TextRun
Strategy 2: findByContentHash()   →  fallback
```

**After v0.4.2 (broken for inline-level):**
```
Strategy 1: findByContentHash()   →  searches //w:body/w:p (body-level only)
Strategy 2: findByTypeAndOrder()  →  never reached due to hash collision
```

The content hash strategy uses XPath `//w:body/w:p` which only matches **direct children** of `<w:body>`, not paragraphs nested inside table cells (`//w:body//w:tbl//w:tc/w:p`). When a body-level paragraph shares the same content hash as a cell paragraph, the locator returns the wrong DOM node, causing `SDTInjector::findParentCell()` to throw:

```
RuntimeException: SDTInjector: Paragraph not inside a table cell (<w:tc>)
```

The most common collision is with **empty content** (`''`), produced by `$section->addTextBreak()`, `$section->addText('')`, or any empty paragraph auto-generated by PHPWord.

Additionally, `SDTInjector::processElement()` did not propagate the existing `$config->inlineLevel` flag to the locator, preventing any inline-aware behavior.

---

### Fix Summary

**2 production files modified, ~19 insertions, 6 deletions:**

#### 1. `ElementLocator::findElementInDOM()` (`src/ElementLocator.php`)

Added `bool $inlineLevel = false` parameter (5th argument). When `inlineLevel=true` AND element is `Text` or `TextRun`, the `findByContentHash()` strategy is skipped entirely. This allows the type+order fallback strategy to run, which already contains `findTextInCell()` and `findTextRunInCell()` methods that correctly search within `<w:tc>` scope.

```php
public function findElementInDOM(
    DOMDocument $dom,
    object $element,
    int $registrationOrder = 0,
    string $rootElement = 'w:body',
    bool $inlineLevel = false          // NEW — default preserves existing behavior
): ?DOMElement {
    // ...

    $skipContentHash = $inlineLevel && (
        $element instanceof \PhpOffice\PhpWord\Element\Text ||
        $element instanceof \PhpOffice\PhpWord\Element\TextRun
    );

    // Strategy 1: By content hash (skipped when $skipContentHash is true)
    if (!$skipContentHash) {
        $contentHash = ElementIdentifier::generateContentHash($element);
        $found = $this->findByContentHash($element, $contentHash, $rootElement);
        if ($found !== null) {
            return $found;
        }
    }

    // Strategy 2: By type + order (fallback — findTextInCell()/findTextRunInCell())
    // ...
}
```

**Design decisions:**
- Default `false` ensures all 20+ existing callers are unaffected (zero backward compatibility breaks)
- `instanceof` checks against `final` PHPWord classes — no subclass risk
- Skip applies only to `Text`/`TextRun` — other element types (Table, Cell, Image, Title) continue using content hash normally

#### 2. `SDTInjector::processElement()` (`src/SDTInjector.php`)

Single-line change propagating the existing `$config->inlineLevel` flag:

```php
// BEFORE (line 198):
$targetElement = $this->locator->findElementInDOM($dom, $element, $elementIndex, $rootElement);

// AFTER:
$targetElement = $this->locator->findElementInDOM($dom, $element, $elementIndex, $rootElement, $config->inlineLevel);
```

`SDTConfig::$inlineLevel` is a `readonly bool` property (always defined, no null-safety concerns). The `$config` variable is already available in method scope.

---

### Reproduction Scenarios

All three conditions must be met simultaneously to trigger the bug:

1. A `Text` or `TextRun` element is registered with `'inlineLevel' => true` (inside a `<w:tc>` cell)
2. A body-level `<w:p>` paragraph exists with the **same content hash** as the cell paragraph
3. The `findByContentHash` strategy runs before `findByTypeAndOrder` (v0.4.2+ behavior)

**Minimal example:**
```php
$cc = new ContentControl();
$section = $cc->addSection();

$table = $section->addTable();
$cell = $table->addRow()->addCell();
$text = $cell->addText('');               // Empty text in cell

$section->addTextBreak();                 // Body-level empty paragraph (same hash)

$cc->addContentControl($text, [
    'alias' => 'EmptyCellText',
    'inlineLevel' => true,
]);

$cc->save('output.docx');                 // v0.5.1: RuntimeException — v0.5.2: works correctly
```

---

### New Tests

**4 Feature Tests** (`tests/Feature/InlineLevelSDTTest.php`):

| Test ID | Scenario | Validates |
|---------|----------|-----------|
| FT06 | Empty Text in cell + `addTextBreak` at body level | Hash collision on empty content |
| FT07 | Matching non-empty text (`-`) in cell and body | Identical non-empty hash collision |
| FT08 | Multiple empty cells + multiple `addTextBreak` | Multi-collision edge case |
| FT09 | TextRun in cell + `addTextBreak` at body level | TextRun variant of collision |

All feature tests:
- Use real DOCX generation (not mocked)
- Validate SDT is inside `<w:tc>` via regex: `/<w:tc>.*<w:sdt>.*alias.*<\/w:sdt>.*<\/w:tc>/s`
- Use `safeUnlink()` for Windows file locking compatibility
- Assert `save()` does NOT throw `RuntimeException`

**1 Unit Test** (`tests/Unit/ElementLocatorTest.php`):

| Test ID | Scenario | Validates |
|---------|----------|-----------|
| UT-INLINE-01 | DOM with body-level and cell-level `<w:p>` containing identical empty content | `inlineLevel=true` returns `parentNode->nodeName === 'w:tc'`; `inlineLevel=false` returns `parentNode->nodeName === 'w:body'` |

---

### Quality Metrics

| Metric | Before (v0.5.1) | After (v0.5.2) |
|--------|------------------|-----------------|
| Tests | 485 passing | 490 passing (+5) |
| Assertions | 1409 | 1423 (+14) |
| PHPStan Level 9 | 0 errors | 0 errors |
| Coverage | >= 82% | 82.2% |
| Backward compatibility | — | 0 breaks |

---

### Risk Assessment

| Risk | Probability | Mitigation |
|------|-------------|------------|
| Default parameter not picked up by existing callers | Very Low | PHP default parameters well-defined; all 20+ call sites use <= 4 args |
| `instanceof` misses a Text subclass | Very Low | PHPWord `Text` and `TextRun` are `final` classes |
| `findTextInCell()` returns wrong cell with identical content | Low | Existing `[not(ancestor::w:sdtContent)][1]` filter handles processed elements; covered by FT08 |
| Strategy skip causes non-inline Text/TextRun to fail | Very Low | Requires BOTH `$inlineLevel=true` AND `instanceof Text/TextRun`; default `false` preserves all body-level behavior |

---

### References

| Document | Path |
|----------|------|
| Bug Report | `.local/issues/issue-content-control.md` |
| Implementation Plan | `.local/plans/plan-20260214-120000.md` |
| Technical Specification | `.local/specs/spec-20260214-120000.md` |
| Code Review | `.local/pull-requests/pr-review-code-20260214-120000.md` |
| ISO/IEC 29500-1:2016 | Section 17.5.2 (Structured Document Tags) |
